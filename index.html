<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>LoreGraph - Emotional Memory</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Polyfill for process.env -->
    <script>
      window.process = { env: { NODE_ENV: 'production' } };
    </script>
    <style>
      body, html { width: 100%; height: 100%; margin: 0; overflow: hidden; }
      body {
        font-family: 'Inter', sans-serif;
        background-color: #0f172a;
        color: #e2e8f0;
      }
      .font-mono { font-family: 'JetBrains Mono', monospace; }
      ::-webkit-scrollbar { width: 8px; height: 8px; }
      ::-webkit-scrollbar-track { background: #1e293b; }
      ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
      ::-webkit-scrollbar-thumb:hover { background: #64748b; }
      
      /* Loading Overlay */
      #loading-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: #020617; z-index: 9999;
        display: flex; flex-direction: column;
        align-items: center; justify-content: center;
        transition: opacity 0.5s;
      }
    </style>
    
    <!-- Import Map for Standalone Execution -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "@google/genai": "https://esm.sh/@google/genai@0.1.1",
    "d3": "https://esm.sh/d3@7.9.0",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
    
    <!-- Babel for in-browser compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Suppress Babel warning -->
    <script>
        window.Babel = { disableScriptTags: true }; 
    </script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="loading-overlay">
      <div class="text-cyan-500 font-bold text-xl mb-2">LoreGraph</div>
      <div id="loading-status" class="text-slate-400 text-sm">Waiting for SillyTavern...</div>
      <div class="text-xs text-slate-600 mt-4">Set API Key in Extensions Menu &rarr; LoreGraph</div>
    </div>
    <div id="root" class="w-full h-full"></div>

    <!-- APPLICATION LOGIC -->
    <script type="text/babel" data-type="module">
      import React, { useState, useEffect, useRef, useMemo } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI } from "@google/genai";
      import * as d3 from 'd3';

      // --- CONSTANTS & TYPES ---
      const AXIS_COLORS = {
        love: '#ec4899', friendship: '#22c55e', kinship: '#14b8a6',
        trust: '#3b82f6', fear: '#9333ea', respect: '#f59e0b',
        desire: '#be123c', discipline: '#94a3b8', power: '#7f1d1d', default: '#475569'
      };

      const INITIAL_GRAPH = {
        nodes: [{ id: 'user', name: 'User', archetype: 'Protagonist', currentMood: 'Neutral', group: 1 }],
        links: []
      };

      // --- MATRIX MATH (Physics Engine) ---
      const ACTION_LIBRARY = {
        "ATTACK": { fear: 0.4, power: 0.8, love: -1.0 },
        "KISS": { love: 0.9, desire: 0.8 },
        "TRUST": { trust: 1.0, friendship: 0.7 },
        "BETRAY": { trust: -0.8, power: 0.5 }
      };
      const dotProduct = (emotions, weights) => {
        let score = 0;
        for(let k in emotions) score += (emotions[k]||0) * (weights[k]||0);
        return score;
      };

      // --- COMPONENTS ---

      // 1. D3 Force Graph
      const ForceGraph = ({ data, width, height, onNodeClick, onLinkClick }) => {
        const svgRef = useRef(null);
        useEffect(() => {
          if (!svgRef.current || !data.nodes.length) return;
          const svg = d3.select(svgRef.current);
          svg.selectAll("*").remove();
          
          const nodes = data.nodes.map(d => ({...d}));
          const links = data.links.map(d => ({...d}));

          const simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(250))
            .force("charge", d3.forceManyBody().strength(-500))
            .force("center", d3.forceCenter(width/2, height/2));

          // Markers
          const defs = svg.append("defs");
          Object.entries(AXIS_COLORS).forEach(([k, c]) => {
             defs.append("marker").attr("id", `arrow-${k}`).attr("viewBox", "0 -5 10 10")
             .attr("refX", 24).attr("refY", 0).attr("markerWidth", 5).attr("markerHeight", 5)
             .attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", c);
          });

          const link = svg.append("g").selectAll("path").data(links).join("path")
            .attr("stroke", d => AXIS_COLORS[d.dominantEmotion] || '#888').attr("stroke-width", 2)
            .attr("marker-end", d => `url(#arrow-${d.dominantEmotion})`)
            .attr("fill", "none").attr("cursor", "pointer")
            .on("click", (e, d) => onLinkClick(data.links.find(l => l.source===d.source.id && l.target===d.target.id)));

          const node = svg.append("g").selectAll("g").data(nodes).join("g")
            .attr("cursor", "pointer")
            .call(d3.drag().on("start", (e,d)=>{if(!e.active)simulation.alphaTarget(0.3).restart();d.fx=d.x;d.fy=d.y})
            .on("drag", (e,d)=>{d.fx=e.x;d.fy=e.y}).on("end", (e,d)=>{if(!e.active)simulation.alphaTarget(0);d.fx=null;d.fy=null}))
            .on("click", (e, d) => onNodeClick(data.nodes.find(n => n.id===d.id)));

          node.append("circle").attr("r", 15).attr("fill", "#1e293b").attr("stroke", "#38bdf8").attr("stroke-width", 2);
          node.append("text").text(d => d.name).attr("y", 25).attr("text-anchor", "middle").attr("fill", "#cbd5e1").style("font-size", "10px");

          simulation.on("tick", () => {
            link.attr("d", d => `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`);
            node.attr("transform", d => `translate(${d.x},${d.y})`);
          });
          
          return () => simulation.stop();
        }, [data, width, height]);
        return <svg ref={svgRef} width={width} height={height} className="w-full h-full" />;
      };

      // 2. Main App
      const App = () => {
        const [apiKey, setApiKey] = useState(null);
        const [graphData, setGraphData] = useState(INITIAL_GRAPH);
        const [messageBuffer, setMessageBuffer] = useState([]);
        const [status, setStatus] = useState("Idle");
        const [selectedItem, setSelectedItem] = useState(null); // {type: 'node'|'link', data: ...}
        const [dims, setDims] = useState({ w: 800, h: 600 });

        // Init
        useEffect(() => {
          const handleMsg = (e) => {
             if(e.data.type === 'CONFIG') {
                 setApiKey(e.data.apiKey);
                 document.getElementById('loading-overlay').style.display = 'none';
             }
             if(e.data.type === 'NEW_CONTEXT') {
                 setMessageBuffer(prev => [...prev, e.data.text]);
             }
             if(e.data.type === 'RESET') {
                 setGraphData(INITIAL_GRAPH);
                 setMessageBuffer([]);
             }
          };
          window.addEventListener('message', handleMsg);
          window.parent.postMessage({ type: 'LOREGRAPH_READY' }, '*'); // Ask ST for config
          
          // Responsive sizing
          const resize = () => setDims({ w: window.innerWidth * 0.7, h: window.innerHeight });
          window.addEventListener('resize', resize);
          resize();
          return () => window.removeEventListener('message', handleMsg);
        }, []);

        // Auto-Process Logic (Debounce)
        useEffect(() => {
            if (messageBuffer.length === 0 || !apiKey) return;
            
            const timer = setTimeout(() => {
                processData();
            }, 2000); // Auto-update 2 seconds after last message
            
            return () => clearTimeout(timer);
        }, [messageBuffer, apiKey]);

        // Gemini Logic
        const processData = async () => {
           setStatus("Analyzing...");
           try {
             const client = new GoogleGenAI({ apiKey });
             const text = messageBuffer.join('\n');
             // Only proceed if valid text
             if(text.length < 5) return;

             const prompt = `
               Analyze interactions for Graph DB.
               Current Nodes: ${JSON.stringify(graphData.nodes.map(n=>n.id))}
               Text: "${text}"
               Return JSON with:
               - nodes: [{id, name, archetype, currentMood}]
               - linkUpdates: [{sourceId, targetId, newEmotions: {love, trust, fear...}, strategicIntent, tone}]
               Use 9-axis (-100 to 100). Detect TONE (SERIOUS/JOKING).
             `;
             
             const res = await client.models.generateContent({
                model: "gemini-2.5-flash",
                contents: prompt,
                config: { responseMimeType: "application/json" }
             });
             
             const raw = JSON.parse(res.text);
             
             // Merge Logic (simplified for standalone)
             let nextNodes = [...graphData.nodes];
             raw.nodes?.forEach(n => {
                const idx = nextNodes.findIndex(x => x.id === n.id);
                if(idx>=0) nextNodes[idx] = {...nextNodes[idx], ...n};
                else nextNodes.push({...n, group: 1});
             });
             
             let nextLinks = [...graphData.links];
             raw.linkUpdates?.forEach(u => {
                let link = nextLinks.find(l => l.source === u.sourceId && l.target === u.targetId);
                let emotions = u.newEmotions;
                // Dampening
                if(u.tone === 'JOKING' && link) {
                    // Average with old values
                    for(let k in emotions) emotions[k] = (emotions[k] + link.emotions[k]) / 2;
                }
                
                // Dom Emotion
                let dom = 'trust'; let max=0;
                for(let k in emotions) if(Math.abs(emotions[k])>max){max=Math.abs(emotions[k]); dom=k;}

                const newLink = {
                    source: u.sourceId, target: u.targetId,
                    emotions, dominantEmotion: dom,
                    strategicIntent: u.strategicIntent,
                    history: link ? [...link.history, u.strategicIntent] : [u.strategicIntent]
                };
                
                const idx = nextLinks.findIndex(l => l.source === u.sourceId && l.target === u.targetId);
                if(idx>=0) nextLinks[idx] = newLink;
                else nextLinks.push(newLink);
             });
             
             const newData = { nodes: nextNodes, links: nextLinks };
             setGraphData(newData);
             setMessageBuffer([]);
             setStatus("Idle");
             
             // AUTO-EXPORT TO SILLYTAVERN
             exportMemory(newData);
             
           } catch(e) {
             console.error(e);
             setStatus("Error");
           }
        };
        
        const exportMemory = (data) => {
            // Generate text summary
            let summary = "[LoreGraph Memory]\n";
            data.links.forEach(l => {
                summary += `${l.source}->${l.target}: ${l.strategicIntent} (Dom: ${l.dominantEmotion})\n`;
            });
            // Send to Parent (Extension.js)
            window.parent.postMessage({ type: 'LOREGRAPH_EXPORT', summary }, '*');
        };

        return (
          <div className="flex h-screen bg-slate-950 text-slate-200">
             {/* Sidebar */}
             <div className="w-64 bg-slate-900 border-r border-slate-800 p-4 flex flex-col">
                <h1 className="text-xl font-bold text-cyan-400">LoreGraph</h1>
                <div className="text-xs text-slate-500 mb-4">v3.0.0 Standalone</div>
                
                <div className="mb-4">
                   <div className="text-xs uppercase text-slate-500">Status</div>
                   <div className={`text-sm font-bold ${status==='Error'?'text-red-400':'text-green-400'}`}>{status}</div>
                </div>
                
                <div className="flex-1 overflow-auto">
                    {selectedItem ? (
                        <div className="text-xs space-y-2">
                           <div className="font-bold text-white">Details</div>
                           <pre className="bg-black p-2 rounded text-[10px] overflow-x-auto">
                             {JSON.stringify(selectedItem, null, 2)}
                           </pre>
                        </div>
                    ) : <div className="text-xs text-slate-600">Select node/link</div>}
                </div>
                
                <div className="mt-auto pt-4 border-t border-slate-800">
                   <div className="text-[10px] text-slate-500">Auto-Updates enabled</div>
                </div>
             </div>
             
             {/* Graph */}
             <div className="flex-1 relative" id="graph-area">
                <ForceGraph 
                   data={graphData} width={dims.w} height={dims.h} 
                   onNodeClick={n => setSelectedItem(n)}
                   onLinkClick={l => setSelectedItem(l)}
                />
             </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>