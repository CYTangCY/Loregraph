<!DOCTYPE html>
<!-- 
  LOREGRAPH STANDALONE DISTRIBUTION
  This file is designed to run directly in SillyTavern without a build step.
  If you are a developer, use 'npm run build' to compile the files in 'src/'.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LoreGraph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="config.js"></script>
    <script>
        window.process = {
            env: {
                NODE_ENV: 'production',
                get API_KEY() { return (window.LOREGRAPH_CONFIG && window.LOREGRAPH_CONFIG.API_KEY) ? window.LOREGRAPH_CONFIG.API_KEY : ''; }
            }
        };
    </script>

    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "d3": "https://esm.sh/d3@7.8.5",
    "@google/genai": "https://esm.sh/@google/genai@0.1.2",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "vite": "https://aistudiocdn.com/vite@^7.2.2",
    "@vitejs/plugin-react": "https://aistudiocdn.com/@vitejs/plugin-react@^5.1.1",
    "path": "https://aistudiocdn.com/path@^0.12.7"
  }
}
</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>body, html, #root { width: 100%; height: 100%; margin: 0; overflow: hidden; background-color: #0f172a; color: #e2e8f0; } .font-mono { font-family: 'JetBrains Mono', monospace; } ::-webkit-scrollbar { width: 6px; height: 6px; } ::-webkit-scrollbar-track { background: #1e293b; } ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }</style>
<link rel="stylesheet" href="/index.css">
</head>
<body>
    <div id="root"></div>
    <script type="text/babel" data-presets="react,typescript">
        // ... [Previous Content of the Standalone Script] ...
        // Since I cannot reference src files here due to CORS in some browsers, 
        // I must keep the Logic INLINE for the 'Install via URL' method to work reliably.
        // The content below duplicates the logic in src/ for immediate execution.
        
        import React, { useState, useEffect, useRef } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as d3 from 'd3';
        import { GoogleGenAI } from "@google/genai";

        const ACTION_LIBRARY = {
            "ATTACK": { fear: 0.4, power: 0.8, love: -1.0, friendship: -0.8, discipline: 0.2 },
            "INTIMIDATE": { power: 0.9, fear: 0.5, respect: 0.3, friendship: -0.5 },
            "BETRAY": { trust: -0.5, desire: 0.2, power: 0.6, kinship: -1.0 },
            "KISS": { love: 0.9, desire: 0.8, trust: 0.5, fear: -0.2 },
            "FLIRT": { desire: 0.7, love: 0.3, friendship: 0.4, discipline: -0.2 },
            "CONFESS_LOVE": { love: 1.0, trust: 0.8, fear: 0.3 },
            "TRUST_CONFIDE": { trust: 1.0, friendship: 0.7, kinship: 0.6, fear: -0.5 },
            "MAKE_DEAL": { respect: 0.8, trust: 0.4, power: 0.1, discipline: 0.5 },
            "ASK_HELP": { trust: 0.8, power: -0.4, friendship: 0.6 },
            "OBEY_ORDER": { discipline: 1.0, fear: 0.4, respect: 0.6, power: -0.5 },
            "REBEL": { discipline: -1.0, power: 0.7, fear: -0.3 },
            "PROTECT": { love: 0.6, kinship: 0.9, discipline: 0.5, fear: 0.2 }
        };

        const STRATEGY_MAPPING = {
            "HOSTILE": ["ATTACK", "INTIMIDATE", "BETRAY", "REBEL"],
            "ROMANTIC": ["KISS", "FLIRT", "CONFESS_LOVE", "PROTECT"],
            "FRIENDLY": ["TRUST_CONFIDE", "ASK_HELP", "PROTECT", "MAKE_DEAL"],
            "PROFESSIONAL": ["MAKE_DEAL", "OBEY_ORDER", "RESPECT", "ASK_HELP"],
            "NEUTRAL": ["MAKE_DEAL", "ASK_HELP"],
            "DOMINANT": ["INTIMIDATE", "OBEY_ORDER", "ATTACK"],
            "SUBMISSIVE": ["OBEY_ORDER", "ASK_HELP", "TRUST_CONFIDE"]
        };

        const AXIS_COLORS = {
            love: '#ec4899', friendship: '#22c55e', kinship: '#14b8a6',
            trust: '#3b82f6', fear: '#9333ea', respect: '#f59e0b',
            desire: '#be123c', discipline: '#94a3b8', power: '#7f1d1d', default: '#475569'
        };

        const dotProduct = (emotions, weights) => {
            let score = 0;
            Object.keys(emotions).forEach(key => { score += (emotions[key] || 0) * (weights[key] || 0); });
            return score;
        };

        const calculateProceduralActions = (emotions, intent, contextScore) => {
            const availableActionKeys = STRATEGY_MAPPING[intent.toUpperCase()] || STRATEGY_MAPPING["NEUTRAL"];
            return availableActionKeys.map(actionKey => {
                const weights = ACTION_LIBRARY[actionKey];
                if (!weights) return { action: actionKey, probability: 0, formula: "Unknown" };
                const dotProd = dotProduct(emotions, weights);
                const diceRoll = Math.floor(Math.random() * 20) + 1;
                const rawScore = dotProd + contextScore + (diceRoll * 2);
                const probability = Math.min(Math.max(Math.round(((rawScore + 150) / 300) * 100), 0), 100);
                return { action: actionKey, probability, formula: `Score(${Math.round(dotProd)}) + Ctx(${contextScore}) + d20` };
            }).sort((a, b) => b.probability - a.probability);
        };

        const analyzeStoryBlock = async (textBlock, currentGraph, godModeInstruction) => {
            if (!process.env.API_KEY || process.env.API_KEY === 'YOUR_API_KEY_HERE') { alert("Please set your API Key in config.js"); throw new Error("Missing API Key"); }
            
            const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
            const existingCharList = currentGraph.nodes.map(n => `${n.id} (${n.name})`).join(", ");

            const prompt = `
                LoreGraph Engine v3.0.
                CHARACTERS: [${existingCharList}]
                INPUT: "${textBlock}"
                ${godModeInstruction ? `OVERRIDE: "${godModeInstruction}"` : ''}
                RULES:
                1. DETECT TONE: 'SERIOUS', 'JOKING', 'SARCASM', 'DECEPTIVE'.
                2. JOKING/SARCASM = Minimal changes.
                3. Output JSON.
            `;

            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash",
                contents: prompt,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            nodes: { type: "ARRAY", items: { type: "OBJECT", properties: { id: { type: "STRING" }, name: { type: "STRING" }, archetype: { type: "STRING" }, currentMood: { type: "STRING" }, group: { type: "INTEGER" }}}},
                            linkUpdates: { type: "ARRAY", items: { type: "OBJECT", properties: {
                                sourceId: { type: "STRING" }, targetId: { type: "STRING" },
                                newEmotions: { type: "OBJECT", properties: { love: { type: "INTEGER" }, friendship: { type: "INTEGER" }, kinship: { type: "INTEGER" }, trust: { type: "INTEGER" }, fear: { type: "INTEGER" }, respect: { type: "INTEGER" }, desire: { type: "INTEGER" }, discipline: { type: "INTEGER" }, power: { type: "INTEGER" }}},
                                strategicIntent: { type: "STRING" }, historyEvent: { type: "STRING" }, contextScore: { type: "INTEGER" }, tone: { type: "STRING", enum: ['SERIOUS', 'JOKING', 'SARCASM', 'DECEPTIVE'] }
                            }}}
                        }
                    }
                }
            });

            const rawData = JSON.parse(response.text);
            const newNodes = [...currentGraph.nodes];
            rawData.nodes?.forEach(rawNode => {
                const idx = newNodes.findIndex(n => n.id === rawNode.id);
                if (idx >= 0) newNodes[idx] = { ...newNodes[idx], ...rawNode };
                else newNodes.push(rawNode);
            });

            let newLinks = [...currentGraph.links];
            rawData.linkUpdates?.forEach(update => {
                let adoptionRate = (update.tone === 'JOKING' || update.tone === 'SARCASM') ? 0.1 : 1.0;
                if (update.tone === 'DECEPTIVE') adoptionRate = 0.3;

                let existingLink = newLinks.find(l => l.source === update.sourceId && l.target === update.targetId);
                let finalEmotions = update.newEmotions || {};

                if (existingLink) {
                    Object.keys(finalEmotions).forEach(key => {
                        const oldVal = existingLink.emotions[key] || 0;
                        const newVal = finalEmotions[key] || 0;
                        finalEmotions[key] = Math.round(oldVal + (newVal - oldVal) * adoptionRate);
                    });
                }

                let maxVal = -1, dominant = 'trust';
                Object.keys(finalEmotions).forEach(k => { if (Math.abs(finalEmotions[k]) > maxVal) { maxVal = Math.abs(finalEmotions[k]); dominant = k; }});

                const actions = calculateProceduralActions(finalEmotions, update.strategicIntent, update.contextScore);
                const historyEntry = { description: update.historyEvent, affectedAxes: finalEmotions, timestamp: new Date().toLocaleTimeString(), tone: update.tone };

                const newLinkData = {
                    source: update.sourceId, target: update.targetId,
                    emotions: finalEmotions, dominantEmotion: dominant,
                    strategicIntent: update.strategicIntent, potentialActions: actions,
                    history: existingLink ? [...existingLink.history, historyEntry] : [historyEntry]
                };

                const linkIdx = newLinks.findIndex(l => l.source === update.sourceId && l.target === update.targetId);
                if (linkIdx >= 0) newLinks[linkIdx] = newLinkData;
                else newLinks.push(newLinkData);
            });

            return { nodes: newNodes, links: newLinks };
        };
        
        const generateSystemPrompt = async (graph) => {
           let output = `[RELATIONSHIP GRAPH STATE]\n`;
           output += `\n-- CHARACTERS --\n`;
           graph.nodes.forEach(n => { output += `[${n.name}]: ${n.currentMood} (Archetype: ${n.archetype})\n`; });
           output += `\n-- DYNAMICS --\n`;
           graph.links.forEach(l => {
               const acts = l.potentialActions.slice(0,2).map(a => `${a.action}(${a.probability}%)`).join(", ");
               output += `${l.source} -> ${l.target} [${l.strategicIntent}]:\n  Dominant: ${l.dominantEmotion.toUpperCase()}\n  Likely Actions: ${acts}\n`;
           });
           return output;
        };

        const AxisSlider = ({ label, value, colorClass, isEditing, onChange }) => (
            <div className="mb-2">
                <div className="flex justify-between text-[9px] uppercase tracking-wider text-slate-400 mb-1"><span>{label}</span><span className={isEditing ? "text-white font-bold" : ""}>{value}</span></div>
                {isEditing ? ( <input type="range" min="-100" max="100" value={value} onChange={(e) => onChange(parseInt(e.target.value))} className="w-full h-1.5 bg-slate-800 rounded-lg appearance-none cursor-pointer accent-white" /> ) : ( <div className="w-full h-1 bg-slate-800 rounded-full overflow-hidden flex items-center relative"><div className="absolute left-1/2 top-0 bottom-0 w-px bg-slate-600/50"></div><div className={`h-full transition-all duration-500 ${colorClass}`} style={{ width: `${Math.abs(value) / 2}%`, marginLeft: value >= 0 ? '50%' : `${50 - (Math.abs(value) / 2)}%` }} /></div> )}
            </div>
        );

        const DetailPanel = ({ selectedNode, selectedLink, onClose, onUpdateLink, onUpdateNode }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [editLink, setEditLink] = useState(null);
            const [editNode, setEditNode] = useState(null);

            useEffect(() => { setIsEditing(false); if (selectedLink) setEditLink({...selectedLink}); if (selectedNode) setEditNode({...selectedNode}); }, [selectedLink, selectedNode]);

            const handleSave = () => {
                if (selectedLink && editLink) {
                    let maxVal = -1, dom = editLink.dominantEmotion;
                    Object.keys(editLink.emotions).forEach(key => { if (Math.abs(editLink.emotions[key]) > maxVal) { maxVal = Math.abs(editLink.emotions[key]); dom = key; }});
                    onUpdateLink({ ...editLink, dominantEmotion: dom });
                }
                if (selectedNode && editNode) onUpdateNode(editNode);
                setIsEditing(false);
            };

            if (!selectedNode && !selectedLink) return <div className="h-full flex items-center justify-center text-slate-500 text-sm p-6">Select a node or link.</div>;

            return (
                <div className="h-full p-6 border-l border-slate-800 bg-slate-900/95 overflow-y-auto">
                    <div className="flex justify-between items-center mb-6"><h2 className="text-lg font-bold text-cyan-400">{selectedNode ? 'Entity Profile' : '9-Axis Analysis'}</h2><div><button onClick={() => isEditing ? handleSave() : setIsEditing(true)} className="text-[10px] px-2 py-1 rounded border border-slate-600 text-slate-400 hover:text-white">{isEditing ? 'Save' : 'Edit'}</button><button onClick={onClose} className="text-slate-400 hover:text-white ml-2">✖</button></div></div>
                    {selectedNode && editNode && (
                        <div className="space-y-4">
                            <div><label className="text-xs text-slate-500">Name</label>{isEditing ? <input className="w-full bg-slate-800 border border-slate-600 rounded px-2 py-1 text-white" value={editNode.name} onChange={e => setEditNode({...editNode, name: e.target.value})} /> : <div className="text-2xl font-mono text-white">{selectedNode.name}</div>}</div>
                            <div className="p-3 bg-slate-800/50 rounded"><label className="text-xs text-slate-500">Mood</label><div className="text-slate-200">{selectedNode.currentMood}</div></div>
                        </div>
                    )}
                    {selectedLink && editLink && (
                        <div className="space-y-6">
                            <div className="flex items-center justify-between p-3 bg-slate-800/50 rounded border border-slate-700"><div className="font-bold text-xs text-slate-300">{editLink.source}</div><div className="text-slate-500">➔</div><div className="font-bold text-xs text-slate-300">{editLink.target}</div></div>
                            <div className="grid grid-cols-3 gap-3 bg-slate-950/30 p-3 rounded border border-slate-800">
                                {Object.keys(editLink.emotions).map(key => ( <AxisSlider key={key} label={key} value={editLink.emotions[key]} colorClass={`bg-${AXIS_COLORS[key]?.replace('#','') || 'slate-500'}`} isEditing={isEditing} onChange={val => setEditLink({...editLink, emotions: {...editLink.emotions, [key]: val}})} /> ))}
                            </div>
                            {!isEditing && editLink.potentialActions && (
                                <div><label className="text-[9px] text-cyan-400 font-bold mb-2 block">Forecast</label>{editLink.potentialActions.map((act, i) => ( <div key={i} className="mb-2"><div className="flex justify-between text-[10px] text-slate-300"><span>{act.action}</span><span>{act.probability}%</span></div><div className="w-full h-1 bg-slate-800 rounded"><div className="h-full bg-cyan-600" style={{width: `${act.probability}%`}}></div></div></div> ))}</div>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        const ForceGraph = ({ data, onNodeClick, onLinkClick, width, height }) => {
            const svgRef = useRef(null);
            useEffect(() => {
                if (!svgRef.current || !data.nodes.length) return;
                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();
                const nodes = data.nodes.map(d => ({ ...d })), links = data.links.map(d => ({ ...d }));
                const sim = d3.forceSimulation(nodes).force("link", d3.forceLink(links).id(d => d.id).distance(200)).force("charge", d3.forceManyBody().strength(-500)).force("center", d3.forceCenter(width / 2, height / 2));
                const defs = svg.append("defs");
                Object.entries(AXIS_COLORS).forEach(([k, c]) => { defs.append("marker").attr("id", `arrow-${k}`).attr("viewBox", "0 -5 10 10").attr("refX", 25).attr("refY", 0).attr("markerWidth", 4).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("fill", c); });
                const link = svg.append("g").selectAll("path").data(links).join("path").attr("stroke", d => AXIS_COLORS[d.dominantEmotion] || '#555').attr("stroke-width", 2).attr("marker-end", d => `url(#arrow-${d.dominantEmotion})`).on("click", (e, d) => { e.stopPropagation(); onLinkClick(data.links.find(l => l.source === d.source.id && l.target === d.target.id)); });
                const node = svg.append("g").selectAll("g").data(nodes).join("g").call(d3.drag().on("start", (e, d) => { if(!e.active) sim.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }).on("drag", (e, d) => { d.fx = e.x; d.fy = e.y; }).on("end", (e, d) => { if(!e.active) sim.alphaTarget(0); d.fx = null; d.fy = null; })).on("click", (e, d) => { e.stopPropagation(); onNodeClick(data.nodes.find(n => n.id === d.id)); });
                node.append("circle").attr("r", 15).attr("fill", "#1e293b").attr("stroke", "#94a3b8").attr("stroke-width", 2);
                node.append("text").text(d => d.name).attr("y", 25).attr("text-anchor", "middle").attr("fill", "#cbd5e1").style("font-size", "10px");
                sim.on("tick", () => { link.attr("d", d => { const dx = d.target.x - d.source.x, dy = d.target.y - d.source.y, dr = Math.sqrt(dx * dx + dy * dy); return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`; }); node.attr("transform", d => `translate(${d.x},${d.y})`); });
                return () => sim.stop();
            }, [data, width, height]);
            return <svg ref={svgRef} width={width} height={height} className="w-full h-full" />;
        };

        const App = () => {
            const [messageBuffer, setMessageBuffer] = useState([]);
            const [graphData, setGraphData] = useState({ nodes: [{ id: 'user', name: 'User', archetype: 'Protagonist', currentMood: 'Neutral', group: 1 }], links: [] });
            const [isLoading, setIsLoading] = useState(false);
            const [selectedNode, setSelectedNode] = useState(null);
            const [selectedLink, setSelectedLink] = useState(null);
            const [godModeText, setGodModeText] = useState('');
            const [dims, setDims] = useState({ w: 800, h: 600 });
            useEffect(() => {
                const handle = (e) => { if (e.data.type === 'NEW_CONTEXT') setMessageBuffer(p => [...p, `[${new Date().toLocaleTimeString()}] ${e.data.payload.text}`]); if (e.data.type === 'RESET_GRAPH') setGraphData({ nodes: [{ id: 'user', name: 'User', archetype: 'Protagonist', currentMood: 'Neutral', group: 1 }], links: [] }); };
                window.addEventListener('message', handle); const updateDim = () => { const el = document.getElementById('graph-container'); if(el) setDims({ w: el.clientWidth, h: el.clientHeight }); }; window.addEventListener('resize', updateDim); updateDim(); return () => window.removeEventListener('message', handle);
            }, []);
            const processBlock = async () => { if (!messageBuffer.length && !godModeText) return; setIsLoading(true); try { const newData = await analyzeStoryBlock(messageBuffer.join('\n'), graphData, godModeText); setGraphData(newData); setMessageBuffer([]); setGodModeText(''); } catch (e) { console.error(e); alert("Analysis failed. Check Console or API Key."); } setIsLoading(false); };
            
            return (
                <div className="flex h-screen bg-slate-950 text-slate-200">
                    <div className="w-1/3 min-w-[300px] flex flex-col border-r border-slate-800 bg-slate-900 p-4">
                        <h1 className="text-xl font-bold text-cyan-400 mb-4">LoreGraph v3</h1>
                        <div className="flex-1 bg-black/30 rounded p-2 mb-4 overflow-y-auto text-xs font-mono border border-slate-800">{messageBuffer.length ? messageBuffer.map((m, i) => <div key={i} className="mb-1 text-slate-400">{m}</div>) : <div className="text-slate-600 text-center mt-10">Waiting for chat...</div>}</div>
                        <textarea value={godModeText} onChange={e => setGodModeText(e.target.value)} placeholder="God Mode Override..." className="w-full h-16 bg-red-950/20 border border-red-900/50 rounded mb-2 p-2 text-xs text-red-200" />
                        <button onClick={processBlock} disabled={isLoading} className="w-full py-3 bg-cyan-700 hover:bg-cyan-600 text-white rounded font-bold disabled:opacity-50">{isLoading ? 'Analyzing...' : 'Process Block'}</button>
                    </div>
                    <div id="graph-container" className="flex-1 relative"><ForceGraph data={graphData} width={dims.w} height={dims.h} onNodeClick={setSelectedNode} onLinkClick={setSelectedLink} /></div>
                    {selectedNode || selectedLink ? ( <div className="w-1/4 min-w-[300px] bg-slate-900 border-l border-slate-800"><DetailPanel selectedNode={selectedNode} selectedLink={selectedLink} onClose={() => { setSelectedNode(null); setSelectedLink(null); }} onUpdateLink={l => setGraphData(prev => ({ ...prev, links: prev.links.map(lnk => (lnk.source === l.source && lnk.target === l.target) ? l : lnk) }))} onUpdateNode={n => setGraphData(prev => ({ ...prev, nodes: prev.nodes.map(node => node.id === n.id ? n : node) }))} /></div> ) : null}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
<script type="module" src="/index.tsx"></script>
</body>
</html>